# 图片浏览器的实现

![]()

如图,功能比较简单的图片浏览器.

## 整体思路

图片浏览使用`UICollectionView`实现,设置`UICollectionViewFlowLayout`横向滚动,`itemSize`为屏幕尺寸,将其变为一个具有重用功能的`UIScrollView`.然后用`UICollectionViewCell`展示每张图片,利用`cell`上的`UIScrollView`对图片进行缩放.

## UIScrollView 缩放处理

首先,需在下面这个代理方法中返回要缩放的子视图,在这里也就是一个`UIImageView`:

```objective-c
- (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView
{
    return _imageView;
}
```

`UIScrollView`的缩放主要和这三个属性有关:

- minimumZoomScale
-  maximumZoomScale
-  zoomScale

`UIScrollView`要想能缩放,必须保证`minimumZoomScale`小于`maximumZoomScale`.

`zoomScale`属性表示当前缩放系数,默认情况下,`zoomScale`的值为`1.0`.该属性的值会被限制在最小值和最大值之间.

修改该值会对被缩放的视图进行缩放,并触发`scrollViewDidZoom:`代理方法.同时,这会改变被缩放视图的`transform`,以及`scrollView`的`contentSize`.

注意,如果新值和旧值一样,`scrollView`并不会对被缩放的视图进行缩放,也就不会触发`scrollViewDidZoom:`代理方法,但是会修改`contentSize`.

由于重用机制,一个`cell`经过重用展示新图片时,此时`cell`上添加的`scrollView`的`zoomScale`很可能不为`1.0`.因此必须先将该值重置为`1.0`,这样才能确保设置`imageView`的`frame`以及`scrollView`的`contentSize`的正确性.

在这里对缩放方案的处理是:无论图片大小,最小缩放比率下令图片宽度和屏幕相同,以最小缩放比率显示图片.

对于大图,将`maximumZoomScale`设置为`1.0`,即最大缩放比率下显示原图.

对于小图,由于已经放大了,因此不允许再继续放大,但是为了保证缩放的弹簧效果,令`maximumZoomScale`比`minimumZoomScale`大`0.000001`,这种微小的差距基本不会对图片进行放大.

另外,由于缩放的弹簧效果,图片可以被缩放的比屏幕范围还小,为了保证图片能居中显示,需要在`scrollViewDidZoom:`代理方法中实时依靠`contentInset`补齐不足的部分.

对于高度会超过屏幕高度的长图,其,显示时需调整`scrollView`的`contentOffset.y`为`0`,使之滚动至图片顶部.而对于一般的高度不足屏幕高度的图,由于`contentInset.top`不为`0`,因此需设置`contentOffset.y`为`-contentInset.top`,图片才能居中.图片高度超过屏幕时`contentInset.top`值为`0`,因此统一设置`contentOffset.y`为`contentInset.top`即可.

```objective-c
- (void)adjustZoomScale
{
    // 防止 minimumZoomScale > 1.0 时限制 zoomScale 无法修改为 1.0 .
    _scrollView.minimumZoomScale = 1.0;
    // 重置缩放变换,否则设置尺寸会受到缩放影响.
    _scrollView.zoomScale = 1.0;

    _imageView.frame = (CGRect){ .size = _imageView.image.size };
    _scrollView.contentSize = _imageView.image.size;

    // 让最小缩放系数下图片宽度和屏幕相同.
    CGFloat zoomScale = self.lx_width / _imageView.lx_width;

    _scrollView.minimumZoomScale = zoomScale;
    // zoomScale >= 1.0 说明图片太小,在放大的情况下才能填充.
    if (zoomScale >= 1.0) {
        // 此时图片已放大至最大,并且无法缩小.为了能触发弹簧效果,需确保 maximumZoomScale > minimumZoomScale.
        _scrollView.maximumZoomScale = zoomScale + 0.000001;
    } else {
        // zoomScale < 1.0 说明图片比较大,需缩小或者原图尺寸才能填充.
        _scrollView.maximumZoomScale = 1.0;
    }

    // 调整当前缩放系数,即若是大图就是以最小形式展示,若是小图就是以最大形式展示(实际上系数小 0.000001).
    _scrollView.zoomScale = zoomScale;

    // 抵消掉 contentInset, 使普通图片居中,长图则滚动至图片顶部.
    _scrollView.contentOffset = CGPointMake(0, -_scrollView.contentInset.top);
}
```

为了保证缩放时图片总是能居中显示,还需要实时调整`contentInset`:

```objective-c
- (void)scrollViewDidZoom:(UIScrollView *)scrollView
{
    // 根据 imageView 实时尺寸调整 contentInset 使之始终能居中显示.
    CGFloat paddingH = _imageView.lx_width < self.lx_width ?
        (self.lx_width - _imageView.lx_width) / 2 : 0;

    CGFloat paddingV = _imageView.lx_height < self.lx_height ?
        (self.lx_height - _imageView.lx_height) / 2 : 0;

    scrollView.contentInset = UIEdgeInsetsMake(paddingV, paddingH, paddingV, paddingH);
}
```
